
:initial_ldl_text :has_value
"""
newline ++> [\\n].
statement works as top_level_item.
newline works as top_level_item.
statements ++> a series of top_level_item separated with newline.

comment works as statement.
comment ++> [#], comment_body.
comment_body ++> all chars until one of [\\n].

identifier ++> builtin-postprocessed identifier_raw.
identifier_raw ++> a series of any char except [\\n\\[\\]\\\\ ] separated with [].

identifier works as node_name.

a_series_of_y_separated_with_z works as grammar_item.
a_series_of_y_separated_with_z ++> [a series of ], item_type:grammar_item, [ separated with ], separator:grammar_item.

builtin_postprocessed works as grammar_item.
builtin_postprocessed ++> [builtin-postprocessed ], node_name.

subtype works as statement.
subtype ++> sub:node_name, [ works as ], sup:node_name.

grammar works as statement.
grammar ++> node_name, [ ++> ], grammar_items.
#alternative syntax for grammar is node_name, [ is ], grammar_items.

grammar_items ++> a series of grammar_item separated with [, ].

string_literal works as grammar_item.
node_name works as grammar_item.
node_name_with_child_name works as grammar_item.
node_name_with_child_name ++> child_name:node_name, [:], type_name:node_name.

string_literal ++> builtin-postprocessed string_literal_raw.
string_literal_raw ++> [\\[], string_literal_body_raw, [\\]].
string_literal_body_raw ++> a series of string_literal_body_raw_item separated with [].
string_literal_body_raw_item ++> any char except [\\n\\[\\]\\\\].
string_literal_body_raw_item ++> [\\\\n].
string_literal_body_raw_item ++> [\\\\\\[].
string_literal_body_raw_item ++> [\\\\\\]].
string_literal_body_raw_item ++> [\\\\\\\\].
""";
:has_comment """
this is a declarative definition of the basic building blocks of the ldl and their grammar.
probably just dcg + "any char except" +  optional child names + "indent"/"dedent" special syntax items.
now we need to turn this into (at least in-memory) ldl ast.
""".

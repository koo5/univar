<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>

	<script type="text/javascript" src="vue.js"></script>
	<script type="text/javascript" src="jquery-3.3.1.js"></script>
	<script src="lodash.js"></script>

	<link rel="stylesheet" href="styles.css">
</head>
<body>
<div id="top">
		<div>step: {{ view.step_id }}</div>
		<coro_state :coro_state="view.root"></coro_state>
		<div> {{ view.yield_count }} </div>
</div>
<script type="text/javascript">

	Vue.component('coro_state', {
		props: ["coro_state"],
		template: `
			<div class="coro_state">
			{{ coro_state.status }} - {{ coro_state.comment }}
			<ul>
			<div v-for="child in coro_state.children" :key="child.id">
				<li>
				<coro_state :coro_state="child"></coro_state>
				</li>
			</div>
			</ul>
			</div>
		`
	});
	var vm = new Vue({
		el: '#top',
		data: {
			view:{
				root:
				{
					status:"hello! loading and parsing trace file...hopefully... ... you have a trace file, right?...",
					children:[],
				},
				step_id: -1,
				yield_count: 0,
			},
			display_rules:[
				{action:"hide",filter:{rule: 0}},
				{action:"hide",filter:{rule: 1}},
			],
		},
		mounted: function ()
		{
			window.addEventListener('keydown', function (event) {
				c = event.keyCode;
				console.log(c);
				if (c==188 && vm.view.step_id > 0)
				{
					prev_step();
				}
				if (c==190 && vm.steps.length > 0)
					go_to_next_step();
				if (c==107 && vm.steps.length > 0)
					go_to_next_deeper_step();
				if (c==191 && vm.steps.length > 0)
					go_to_next_yield();
			});
		}
	});

	const snapshot_interval = 80;

	function maybe_take_snapshot()
	{
		const step_id = vm.view.step_id;
		if (step_id % snapshot_interval == 0)
			if (vm.snapshots[step_id] === undefined)
				vm.snapshots[step_id] = _.cloneDeep(vm.view);
	}
/*	function go_to_next_deeper_step()
	{
		console.log("go_to_next_deeper_step");
		move_view_to_next_step(vm.view)
	}*/
	function go_to_next_yield()
	{
		console.log("go_to_next_yield");
		const old_yields = vm.view.yield_count;
		for (i = 0; i < 100; i++)
		{
			go_to_next_step()
			if (old_yields < vm.view.yield_count)
				break;
		}	
	}
	function go_to_next_step()
	{
		console.log("go_to_next_step");
		maybe_take_snapshot();
		move_view_to_next_step(vm.view)
	}
	function move_view_to_next_step(view)
	{
		const wanted_id = view.step_id+1
		const step = vm.steps[wanted_id];
		if (step != undefined)
		{
			view.step_id++
			step.forEach(op => {do_op(op, view)})
			return true;
		}
		else
		{
		
		}
		return false;
	}
	function prev_step()
	{
		console.log('prev_step')
		const wanted = vm.view.step_id - 1;
		let best = 0; // we never delete the 0 snapshot
		for (let idx = 0; idx < vm.snapshots.length; idx++)
		{
			if (idx > wanted)
				break;
			let snapshot = vm.snapshots[idx]
			if (snapshot != undefined)
				best = idx
		}
		//now best is the position of the closest snapshot
		let snapshot = _.cloneDeep(vm.snapshots[best])
		while (wanted > snapshot.step_id)
		{
			if (!move_view_to_next_step(snapshot))
			{
				alert("fail");
				return;
			}
		}
		assert (snapshot.step_id == wanted);
		assign_cloned_snapshot_to_view(snapshot);
	}
	function assign_cloned_snapshot_to_view(snapshot)
	{
		assign_cloned_snapshot_to_view1(snapshot)
		assign_cloned_snapshot_to_view2(snapshot)
		vm.view.step_id = snapshot.step_id;
	}
	function assign_cloned_snapshot_to_view1(snapshot)
	{
		vm.view.index = snapshot.index;
	}
	function assign_cloned_snapshot_to_view2(snapshot)
	{
		vm.view.root = snapshot.root
	}
	function do_op(op, view)
	{
		const action = op[0]
		const id = op[1]
		if (action == OP_SET_COMMENT)
		{
			if (view.index[id] == undefined)
				alert("comment before status for id "+id);
			view.index[id].comment = op[2];
		}
		else if (action == OP_SET_STATUS)
		{
			//console.log(op.id + " status "  +  coro_status[op.status]);
			if (view.index[id] == undefined)
			{
				if (op.parent_id == undefined)
					alert("first status but no parent id?");
				if (!add_state(op, view))
					return
			}
			comment = op[4]
			if (comment != undefined)
				view.index[id].comment = comment;

			status = op[2]
			const old_status_string = view.index[id].status;
			const new_status_string = coro_status[status];
			const yield_statuses = ["EP", "YIELD", "BNODE_YIELD"];
			if (yield_statuses.includes(old_status_string) && !yield_statuses.includes(new_status_string))
				assert(--view.yield_count > 0)
			else if (yield_statuses.includes(new_status_string) && !yield_statuses.includes(old_status_string))
				view.yield_count++

			view.index[id].status = new_status_string

			if (status === 0)
			{
				/*when a state is inactivated, its children
				will never be used again*/
				view.index[id].children.forEach(child => 
					remove_state(child.id, view));
				view.index[id].children = []
				if (view.index[id].parent == view.root)
					remove_state(id, view);			
			}
		}
		else 
			alert("unknown action:"+action)
	}
	function add_state(op, view)
	{
		state = {"children":[],"status":"idk"};
		state.id = op[1];
		const parent_id = op[3];
		state.parent_id = parent_id;
		if (view.index.hasOwnProperty(parent_id))
			parent = view.index[parent_id]
		else
			parent = view.root
		state.parent = parent
		parent.children.push(state)
		view.index[state.id] = state;
		return true;
	}
	function remove_state(id, view)
	{
		delete view.index[id]
	}
	
	const coro_status = ["INACTIVE", "ACTIVE", "EP", "YIELD", "BNODE_YIELD"]
	const OP_ADD_COMMENT = 0;
	const OP_SET_STATE = 1;
	
$( document ).ready(function() {



/*we initialize these from here, because if they were in the initial data declaration, vue would reactivize them
and things would get silly slow. I first looked for solutions like this one:
//Object.defineProperty(vm.view, 'index', {configurable:false});
but none worked*/

vm.view.index = {}
vm.snapshots= []
vm.steps= []
//vm.view.yield_count = 0


console.log( "ready!" );
$.getScript( "../trace0.js", function( data, textStatus, jqxhr ) {
 // console.log( data ); // Data returned
  console.log( textStatus ); // Success
  console.log( jqxhr.status ); // 200
  console.log( "Load was performed." )
  go_to_next_step();
});    
});

	/*this is the function called from withing the trace files*/
	function S(x)
	{
		vm.steps.push(x);
	}


function assert(condition, message) {
    if (!condition) {
        message = message || "Assertion failed";
        if (typeof Error !== "undefined") {
            throw new Error(message);
        }
        throw message; // Fallback
    }
}

</script>
</body>
</html>

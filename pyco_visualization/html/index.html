<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>

	<script type="text/javascript" src="vue.js"></script>
	<script type="text/javascript" src="jquery-3.3.1.js"></script>
	<script src="lodash.js"></script>

	<link rel="stylesheet" href="styles.css">
</head>
<body>
<div id="top">
		<div>last_loaded_file_id: {{ last_loaded_file_id }}, status: {{ file_status }}</div>
		<div>navigation status: {{ navigation_status }}</div>
		<div>yields: {{ view.yield_count }} </div>
		<div>step: {{ view.step_id }}</div>
		<coro_state :coro_state="view.root"></coro_state>
		<div> rules:
			<dl>
			<div v-for="(rule, id) in rules" :key="id">
				<dt> {{ id }}	</dt>
				<dd> {{ rule }}	</dd>
			</div>
			</dl>
		</div>
</div>
<script type="text/javascript">

	Vue.component('coro_state', {
		props: ["coro_state"],
		template: `
			<div class="coro_state">
			{{ coro_state.status }} - {{ coro_state.comment }}
			<ul>
			<div v-for="local_idx in _.range(coro_state.locals.length)">
				<li>
				?{{ names_of_locals[local_idx] }}:
				{{ coro_state.locals[local_idx] }}
				</li>
			</div>
			</ul>
			<ul>
			<div v-for="child in coro_state.children" :key="child.id">
				<li>
				<coro_state :coro_state="child"></coro_state>
				</li>
			</div>
			</ul>
			</div>
		`,
		computed: {
			names_of_locals: function()
			{
				r = [];

				if (this.coro_state.rule_id === -1)
					for (local_idx in _.range(this.coro_state.locals.length))
						r.push('?');
				else
				{
					rule = rule_for_state(this.coro_state);
					//console.log(this)
					for (local_idx in _.range(this.coro_state.locals.length)) {
						name = ''
						v = rule["k:has_locals"]["rdf:value"]["@list"][local_idx]
						if (v["@type"] === "k:existential")
							name += '(E)'
						name += v["k:has_name"]
						r.push(name)
					}
				}
				return r
			}
		}
	});
	var vm = new Vue({
		el: '#top',
		watch: {'view.root.locals': function(x,y){}, deep: true},
		data: {
			view:{
				root:
				{
					status:"hello! loading and parsing trace file...hopefully... ... you have a trace file, right?...",
					children:[],
					locals:[],
					comment:"?"
				},
				step_id: -1,
				yield_count: 0,
			},
			/*display_rules:[
				{action:"hide",filter:{rule: 0}},
				{action:"hide",filter:{rule: 1}},
			],*/
			run_uuid: undefined,
			files:[],
			last_loaded_file_id: -1,
			file_status: "?",
			navigation_status: "?",
			rules:[]
		},
		mounted: function ()
		{
			window.addEventListener('keydown', function (event) {
				c = event.keyCode;
				console.log(c);
				if (c==188 && vm.view.step_id > 0)
				{
					prev_step();
				}
				if (c==190 && vm.steps.length > 0)
				{
					vm.navigation_status = "going to next step.."
					go_to_next_step();
					vm.navigation_status = "idle"
				}
				if (c==107 && vm.steps.length > 0)
					go_to_next_deeper_step();
				if (c==191 && vm.steps.length > 0)
				{
					vm.navigation_status = "going to next yield.."
					go_to_next_yield();
					vm.navigation_status = "idle"
				}
				if (c==221)
				{
					console.log("ffffff")
					ff();
				}
			});
		}
	});

	const snapshot_interval = 10;
	thing_size = undefined;

	function maybe_take_snapshot()
	{
		const step_id = vm.view.step_id;
		if (step_id % snapshot_interval == 0)
			if (vm.snapshots[step_id] === undefined)
				vm.snapshots[step_id] = _.cloneDeep(vm.view);
	}
	/*function go_to_next_deeper_step()
	{
		console.log("go_to_next_deeper_step");
		move_view_to_next_step(vm.view)
	}*/
	function go_to_next_yield()
	{
		console.log("go_to_next_yield");
		const old_yields = vm.view.yield_count;
		for (i = 0; i < 100; i++)
		{
			if (!go_to_next_step())
				break;
			if (old_yields < vm.view.yield_count)
				break;
		}
	}
	function ff()
	{
		console.log("ff");
		for (var i = 0; i < 50000; i++)
		{
			if (!move_view_to_next_step(vm.view))
				break;
		}
	}
	function go_to_next_step()
	{
		console.log("go_to_next_step");
		maybe_take_snapshot();
		return move_view_to_next_step(vm.view)
	}
	function move_view_to_next_step(view)
	{
		const wanted_id = view.step_id + 1
		const step = vm.steps[wanted_id];
		if (step != undefined)
		{
			view.step_id++
			for (i = 0; i < step.length; i++)
				if (!do_op(step[i], view))
					return false
			return true;
		}
		else
		{
			load_file_for_step(wanted_id);
			return false;
		}
	}
	function load_file_for_step(wanted)
	{	/*
		files.forEach(file => {
			if (file.status == FileStatus.unloaded)
			{
				if (file.start <= wanted && file.end >= wanted)

		})
		*/
		load_file(vm.last_loaded_file_id + 1);
	}
	function load_file(id)
	{
		if (vm.file_status == "loading")
			return
		vm.file_status = "loading"
		$.getScript( "../trace"+id+".js", function( data, textStatus, jqxhr )
		{
			console.log( textStatus ); // Success
			console.log( jqxhr.status ); // 200
			console.log( "Load was performed." )
			//if (view.step_id == -1)
			//go_to_next_step();
			go_to_next_yield();

			vm.last_loaded_file_id++
			vm.file_status = "loaded"
		});
	}
	function prev_step()
	{
		console.log('prev_step')
		const wanted = vm.view.step_id - 1;
		let best = 0; // we never delete the 0 snapshot
		for (let idx = 0; idx < vm.snapshots.length; idx++)
		{
			if (idx > wanted)
				break;
			let snapshot = vm.snapshots[idx]
			if (snapshot != undefined)
				best = idx
		}
		//now best is the position of the closest snapshot
		let snapshot = _.cloneDeep(vm.snapshots[best])
		while (wanted > snapshot.step_id)
		{
			if (!move_view_to_next_step(snapshot))
			{
				alert("fail");
				return;
			}
		}
		assert (snapshot.step_id == wanted);
		assign_cloned_snapshot_to_view(snapshot);
	}
	function assign_cloned_snapshot_to_view(snapshot)
	{
		/*vm.view.yield_count = snapshot.yield_count
		vm.view.step_id = snapshot.step_id;
		vm.view.index = snapshot.index;
		vm.view.root = snapshot.root*/
		vm.view = snapshot
	}
	function do_op(op, view)
	{
		if (!Array.isArray(op))
		{
			if (op["a"] == "run_uuid")
			{
				uuid = op["value"]
				if (vm.run_uuid === undefined)
					vm.run_uuid = uuid
				else if (vm.run_uuid != uuid)
				{
					files[file_id].status = FileStatus.error
					alert("uuids dont match");
					return false
				}
			}
			else if (op["a"] == "consts_address")
			{
				const rule_id = parseInt(op["rule"])
				vm.rules[rule_id].consts_address = op["consts"]
			}
			else if (op["a"] == "thing_size")
			{
				thing_size = op["value"]
			}
			else
				alert("unknown action in " + op)
			return true
		}
		const action = op[0]
		const id = op[1]
		if (action == OP_SET_COMMENT)
		{
			if (view.index[id] == undefined)
				alert("comment before status for id "+id);
			view.index[id].comment = op[2];
		}
		else if (action == OP_SET_STATUS)
		{
			//console.log(op.id + " status "  +  coro_status[op.status]);
			parent_id = op[3]
			if (view.index[id] == undefined)
			{
				if (parent_id == undefined)
					alert("first status but no parent id?");
				if (!add_state(op, view))
					return
			}
			comment = op[6]
			if (comment != undefined)
				view.index[id].comment = comment;

			status = op[2]
			const old_status_string = view.index[id].status;
			const new_status_string = coro_status[status];
			const yield_statuses = ["EP", "YIELD", "BNODE_YIELD"];
			if (yield_statuses.includes(old_status_string) && !yield_statuses.includes(new_status_string))
				assert(--view.yield_count >= 0)
			else if (yield_statuses.includes(new_status_string) && !yield_statuses.includes(old_status_string))
				view.yield_count++

			view.index[id].status = new_status_string

			//console.log(id+" status:"+status)
			if (status == 0)
			{
				if (view.index[id].children.length)
				{
					//console.log("deleting inactive parent's children")
					/*when a state is inactivated, its children
					will never be used again*/
					view.index[id].children.forEach(child =>
						remove_state(child.id, view));
					view.index[id].children = []
					//if (view.index[id].parent == view.root)
					//remove_state(id, view);
				}
				//else console.log("chl")

			}
			//else console.log(id+" status != 0")

		}
		else if (action == OP_BIND) {
			what = parseInt(op[1])
			where = parseInt(op[2])
			what_thing = undefined
			where_thing = undefined
			for (const i in view.index)
			{
				console.log(i)
				console.log(typeof(i))
				state = view.index[i]
				assert (state != undefined)
				console.log("trying " + i + " " + state + " for "+ what)
				thing = local_for_state(state, what)
				console.log(thing)
				if (thing !== undefined) {
					what_thing = thing
					if (where_thing) {
						bind(what_thing, where_thing);
						return true;
					}
				}
				thing = local_for_state(state, where)
				if (thing !== undefined) {
					where_thing = thing
					if (what_thing) {
						bind(what_thing, where_thing);
						return true;
					}
				}
			}
			for (const i in vm.rules)
			{
				rule = vm.rules[i]
				thing = const_for_rule(rule, where)
				if (thing !== undefined) {
					where_thing = thing
					if (what_thing) {
						bind(what_thing, where_thing);
						return true;
					}
					else //throw new Error("no what?")
							console.log("unknown thing: " + where)
				}
			}
		}
		else if (action == OP_UNBIND) {
			what = parseInt(op[1])
			for (const i in view.index)
			{
				state = view.index[i]
				thing = local_for_state(state, what)
				if (thing !== undefined)
				{
					thing.bound_to = undefined;
					return true;
				}
			}
		}
		else
			alert("unknown action: "+action)
		return true
	}
	function bind(what_thing, where_thing) {
		what_thing.bound_to = where_thing;
	}
	function local_for_state(state, what)
	{
		if (state.rule_id != -1)
			size = locals_template_for_rule(rule_for_state(state)).length
		else
			if (state.locals_size !== undefined)
				size = state.locals_size
			else
				return
		return state.locals[thing_idx(what, state.locals_address, size)]
	}
	function locals_template_for_rule(rule)
	{
		return rule['k:has_locals']['rdf:value']['@list']
	}
	function const_for_rule(rule, what)
	{
		return rule.consts[thing_idx(what, rule.consts_address, rule.consts.length)]
	}
	function thing_idx(what, locals_address, locals_count)
	{
		offset = what - locals_address
		if (offset >= 0 && offset <= (locals_count - 1) * thing_size)
			return offset/thing_size
	}
	function add_state(op, view)
	{
		state = {children:[],status:"idk",locals:[],comment:"???"};
		state.id = op[1];
		const parent_id = op[3];
		state.parent_id = parent_id;
		if (view.index.hasOwnProperty(parent_id))
			parent = view.index[parent_id]
		else
			parent = view.root
		state.parent = parent
		parent.children.push(state)
		view.index[state.id] = state;
		state.locals_address = op[5]
		state.rule_id = op[4]
		if (state.rule_id != -1) {
			rule = rule_for_state(state)
			locals = locals_for_rule(rule)
			locals_count = locals.length
			state.locals = Array(locals_count)
			_.range(locals_count).forEach(i => {
				state.locals[i] = {}
			});
		}
		return true;
	}
	function locals_for_rule(rule)
	{
		console.log(rule)
		return rule["k:has_locals"]["rdf:value"]["@list"]
	}
	function rule_for_state(state)
	{
		return vm.rules[state.rule_id]
	}
	function remove_state(id, view)
	{
		delete view.index[id]
	}
	function get_value(thing)
	{
		if (thing.bound_to)
			return get_value(thing.bound_to)
		return thing
	}

	const FileStatus = Object.freeze({error:1, loading:2, loaded:3, unloaded:4})
	const coro_status = ["INACTIVE", "ACTIVE", "EP", "YIELD", "BNODE_YIELD"]
	const OP_SET_COMMENT = 0;
	const OP_SET_STATUS = 1;
	const OP_BIND = 2;
	const OP_UNBIND = 3;


	$( document ).ready(function() {

/*we initialize these from here, because if they were in the initial data declaration, vue would reactivize them
and things would get silly slow. I first looked for solutions like this one:
//Object.defineProperty(vm.view, 'index', {configurable:false});
but none worked*/

vm.view.index = {}
vm.snapshots= []
vm.steps= []

console.log( "ready!" );

$.ajax({
	dataType: "json",
	url: "../rules.jsonld",
	data: "",
	success: function(data)
	{
		g = data["@graph"]
		g.forEach(rule => {
			//console.log(rule)
			vm.rules[parseInt(rule.has_id)] = rule
			rule.consts = rule["k:has_consts"]["rdf:value"]["@list"]
			delete rule["k:has_consts"]["rdf:value"]["@list"]
			rule.consts_count = rule.consts.length
		})
		load_file(0);
	}
});



});

	/*this is the function called from withing the trace files*/
	function S(x)
	{
		vm.steps.push(x);
	}


function assert(condition, message) {
    if (!condition) {
        message = message || "Assertion failed";
        if (typeof Error !== "undefined") {
            throw new Error(message);
        }
        throw message; // Fallback
    }
}

</script>
</body>
</html>

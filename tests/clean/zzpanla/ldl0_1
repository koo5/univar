@keywords a .
@prefix rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix ldl:      <http://ldl.ldl#> .
@prefix string_builtins: <http://loworbit.now.im/rdf/string_builtins#>.
@prefix tau_builtins: <http://loworbit.now.im/rdf/tau_builtins#>.

@prefix : <file://>.


kb

?builtins_aware_list rdf:first ?ITEM; rdf:rest ?REST.

{?X :eq ?X.} <= {}.

:zero a :nat.
{?x a :nat. ?y :has_succ ?x.} <= {?y a :nat}.
:minus_one a :negative_nat.
{?x a :negative_nat. ?x :has_succ ?y.} <= {?y a :negative_nat}.

{
  ?LIST rdf:first ?FIRST .
} => {
  ?FIRST :memberof ?LIST .
} .
{
  ?R1 rdf:rest ?R .
  ?X :memberof ?R .
} => { 
  ?X :memberof ?R1 .
} .




#character classess
"a" :is_letter :true.
"b" :is_letter :true.
"c" :is_letter :true.
"d" :is_letter :true.
"e" :is_letter :true.
"f" :is_letter :true.
"g" :is_letter :true.
"h" :is_letter :true.
"i" :is_letter :true.
"j" :is_letter :true.
"k" :is_letter :true.
"l" :is_letter :true.
"m" :is_letter :true.
"n" :is_letter :true.
"o" :is_letter :true.
"p" :is_letter :true.
"q" :is_letter :true.
"r" :is_letter :true.
"s" :is_letter :true.
"t" :is_letter :true.
"u" :is_letter :true.
"v" :is_letter :true.
"w" :is_letter :true.
"x" :is_letter :true.
"y" :is_letter :true.
"z" :is_letter :true.
"A" :is_letter :true.
"B" :is_letter :true.
"C" :is_letter :true.
"D" :is_letter :true.
"E" :is_letter :true.
"F" :is_letter :true.
"G" :is_letter :true.
"H" :is_letter :true.
"I" :is_letter :true.
"J" :is_letter :true.
"K" :is_letter :true.
"L" :is_letter :true.
"M" :is_letter :true.
"N" :is_letter :true.
"O" :is_letter :true.
"P" :is_letter :true.
"Q" :is_letter :true.
"R" :is_letter :true.
"S" :is_letter :true.
"T" :is_letter :true.
"U" :is_letter :true.
"V" :is_letter :true.
"W" :is_letter :true.
"X" :is_letter :true.
"Y" :is_letter :true.
"Z" :is_letter :true.
"_" :allowed_as_identifier_first_char :true.
{?x :allowed_as_identifier_first_char :true} <= {?x :is_letter :true}.
{?x :allowed_as_identifier_char :true} <= {?x :allowed_as_identifier_first_char :true}.
{?x :allowed_as_identifier_char :true} <= {?x :is_number :true}.

"0" :is_number :true.
"1" :is_number :true.
"2" :is_number :true.
"3" :is_number :true.
"4" :is_number :true.
"5" :is_number :true.
"6" :is_number :true.
"7" :is_number :true.
"8" :is_number :true.
"9" :is_number :true.

{?x :allowed_in_literal :true} <= {?x :allowed_as_identifier_char :true}.
" " :allowed_in_literal :true.
"~" :allowed_in_literal :true.
"!" :allowed_in_literal :true.
"@" :allowed_in_literal :true.
"#" :allowed_in_literal :true.
"$" :allowed_in_literal :true.
"%" :allowed_in_literal :true.
"^" :allowed_in_literal :true.
"&" :allowed_in_literal :true.
"*" :allowed_in_literal :true.
"(" :allowed_in_literal :true.
")" :allowed_in_literal :true.
"-" :allowed_in_literal :true.
"=" :allowed_in_literal :true.
"+" :allowed_in_literal :true.
"<" :allowed_in_literal :true.
">" :allowed_in_literal :true.
"{" :allowed_in_literal :true.
"}" :allowed_in_literal :true.
"'" :allowed_in_literal :true.
"\"" :allowed_in_literal :true.
"|" :allowed_in_literal :true.
"," :allowed_in_literal :true.
"." :allowed_in_literal :true.
"/" :allowed_in_literal :true.
";" :allowed_in_literal :true.
":" :allowed_in_literal :true.
"`" :allowed_in_literal :true.




#parser of simple dcg
{:dummy :parses_to_rhs (?x0 ?rest ?rhs_)} <= {
	:dummy :rhs_item (?x0 ?after_rhs_item ?rhsf).
	:dummy :maybe_more_rhs_items (?after_rhs_item ?end ?rhsr).
	?end rdf:first ".". ?end rdf:rest ?rest.
}.

{:dummy :parses_to_rhs (?x0 ?rest rdf:nil)} <= {
	?x0 rdf:first ".". ?x0 rdf:rest ?rest.
}.

{:dummy :maybe_more_rhs_items (?x0 ?rest ?items)} <= {
	?items rdf:first ?item. ?items rdf:rest ?items_rest.
	?x0 rdf:first ",". ?x0 rdf:rest ?after_comma.
	?after_comma rdf:first " ". ?after_comma rdf:rest ?after_space.
	:dummy :rhs_item (?after_space ?after_item ?item).
	:dummy :maybe_more_rhs_items (?after_item ?rest ?items_rest).
}.

{:dummy :maybe_more_rhs_items (?x0 ?x0 rdf:nil)} <= {
}.

{:dummy :rhs_item (?x0 ?rest ?item)} <= {
	?item a :identifier. ?item :name ?name.
	:dummy :identifier (?x0 ?rest ?name).
}.

{:dummy :rhs_item (?x0 ?rest ?item)} <= {
	?item a :literal. ?item :value ?string.
	:dummy :literal (?x0 ?rest ?string).
}.

{:dummy :rhs_item (?x0 ?rest ?item)} <= {
	?item a :any_char_except. ?item :value ?except.
	:dummy :literally_string (?x0 ?before_value "any char except ").
	:dummy :literal (?before_value ?rest ?except).
}.

{:dummy :rhs_item (?x0 ?rest ?item)} <= {
	?item a :all_chars_until_one_of. ?item :value ?except.
	:dummy :literally_string (?x0 ?before_value "all chars until one of ").
	:dummy :literal (?before_value ?rest ?except).
}.

{:dummy :arrow (?x0 ?rest)} <= {
	:dummy :literally_string (?x0 ?rest " --> ").
}.

{:dummy :literally_string (?x0 ?rest ?value)} <= {
	?value string_builtins:is_split ?l.
	:dummy :literally_list (?x0 ?rest ?l).
}.

{:dummy :literally_list (?x_ ?rest ?value)} <= {
	?value rdf:first ?xf.
	?value rdf:rest ?vr.
	:dummy :literally_list (?xr ?rest ?vr).
}.

{:dummy :literally_list (?x0 ?x0 rdf:nil)} <= {
}.

{:dummy :literal (?x0 ?rest ?val)} <= {
	?x0 rdf:first "[". ?x0 rdf:rest ?after_opening.
	:dummy :rest_of_literal (?after_opening ?after_value ?val).
	?after_value rdf:first "]". ?after_value rdf:rest ?rest.
}.

{:dummy :statement (?x0 ?rest ?ast)} <= {
	?ast a :statement. ?ast :lhs ?name. ?ast :rhs ?rhs.

	:dummy :identifier (?x0 ?after_identifier ?name).
	:dummy :arrow (?after_identifier ?after_arrow).
	:dummy :parses_to_rhs (?after_arrow ?rest ?rhs).
}.

{:dummy :identifier (?x_ ?rest ?name)} <= {
	?xf :allowed_as_identifier_first_char :true.
	?name rdf:first ?xf. ?name rdf:rest ?rest_of_name.
	:dummy :rest_of_name (?xr ?rest ?rest_of_name).
}.

{:dummy :rest_of_name (?x0 ?x0 rdf:nil)} <= {
}.

{:dummy :rest_of_name (?x0 ?rest ?name)} <= {
	?x0 rdf:first ?f. ?name rdf:first ?f. 
	?f :allowed_as_identifier_char :true.
	#:dummy tau_builtins:output "rest of name:". :dummy tau_builtins:output ?f.
	?x0 rdf:rest ?r. ?name rdf:rest ?name_rest.
	:dummy :rest_of_name (?r ?rest ?name_rest).
}.

{:dummy :rest_of_literal (?x0 ?x0 rdf:nil)} <= {
}.

{:dummy :rest_of_literal (?x_ ?rest ?val_)} <= {
	?valf :eq ?xf.
	?xf :allowed_in_literal :true.
	#:dummy tau_builtins:output "rest of name:". :dummy tau_builtins:output ?xf.
	:dummy :rest_of_literal (?xr ?rest ?valr).
}.

"\n" :has_escape_code "n".
"\\" :has_escape_code "\\".
"]" :has_escape_code "]".
"[" :has_escape_code "[".

{:dummy :rest_of_literal (?x0 ?rest ?val)} <= {
	?real :has_escape_code ?escape.
	?val rdf:first ?real. ?val rdf:rest ?val_rest.
    ?x0  rdf:first "\\". ?x0 rdf:rest ?x1.  ?x1 rdf:first ?escape. ?x1 rdf:rest ?x2.
	:dummy :rest_of_literal (?x2 ?rest ?val_rest).
}.

{:dummy :newline (?x0 ?rest)} <= {
		#?x0 rdf:first ?f.:dummy tau_builtins:output "newline?:". :dummy tau_builtins:output ?f.
	?x0 rdf:first "\n". 
		#:dummy tau_builtins:output "yes".
	?x0 rdf:rest ?rest.
}.

#statement_lines --> statement_line, statement_lines.
{:dummy :statement_lines (?x0 ?rest ?items)} <= {
	?items rdf:first ?item. ?items rdf:rest ?items_rest.
	:dummy :statement_line (?x0 ?after_line ?item).
	:dummy :statement_lines (?after_line ?rest ?items_rest).
}.

#statement_lines --> .
{:dummy :statement_lines (?x0 ?x0 rdf:nil)} <= {
}.

#statement_line --> newline.
{:dummy :statement_line (?x0 ?rest ?item)} <= {
	:dummy :newline (?x0 ?rest).
	?item a :newline.
}.

#statement_line --> statement, newline.
{:dummy :statement_line (?x0 ?rest ?item)} <= {
	:dummy :statement (?x0 ?after_statement ?item).
	:dummy :newline (?after_statement ?rest).
}.





#a post-processor for the dcg
{rdf:nil :concrete_to_abstract rdf:nil} <= {
}.

{?cst :concrete_to_abstract ?ast} <= {
	?cst rdf:first ?cf.
	?cf a :newline.
	?cst rdf:rest ?cr. ?cr :concrete_to_abstract ?ast.
}.

{?c_ :concrete_to_abstract ?a_} <= {
	?cf a :statement. ?cf :concrete_to_abstract_statement ?af.
	?cr :concrete_to_abstract ?ar.
}.

{?c :concrete_to_abstract_statement ?a} <= {
	?c :lhs ?clhs. ?a :lhs ?alhs.
	?alhs string_builtins:strXlst ?clhs.
	?c :rhs ?crhs. ?a :rhs ?arhs.
	?crhs :concrete_to_abstract_rhs ?arhs.
}.

{rdf:nil :concrete_to_abstract_rhs rdf:nil} <= {}.

{?c_ :concrete_to_abstract_rhs ?a_} <= {
	?cf :concrete_to_abstract_rhs_item ?af.
	?cr :concrete_to_abstract_rhs ?ar.
}.

{?c :concrete_to_abstract_rhs_item ?a} <= {
	?c a :identifier. ?c :name ?cname.
	?a a :identifier. ?a :name ?aname.
	?aname string_builtins:strXlst ?cname.
}.

{?c :concrete_to_abstract_rhs_item ?a} <= {
	?c a :any_char_except. ?c :value ?cv.
	?a a :any_char_except. ?a :value ?av.
	?av string_builtins:strXlst ?cv.
}.

{?c :concrete_to_abstract_rhs_item ?a} <= {
	?c a :all_chars_until_one_of. ?c :value ?cv.
	?a a :all_chars_until_one_of. ?a :value ?av.
	?av string_builtins:strXlst ?cv.
}.

{?c :concrete_to_abstract_rhs_item ?c} <= {
	?c a :literal.
}.






#parse something with the grammar
{(?x0 ?grammar ?nont) :parse_nonterminal (?rest ?ast ?depth)} <= {
	?depth_predecessor :has_succ ?depth.
	?rule :memberof ?grammar. 
		#:dummy tau_builtins:output "testing rule lhs...".
	?rule :lhs ?nont. ?rule :rhs ?rhs.
		:dummy tau_builtins:output ?nont.
		:dummy tau_builtins:output "rule...".
	(?x0 ?grammar ?rhs) :parse_rhs (?rest ?ast ?depth_predecessor).
}.

{(?x0 ?grammar ?rhs) :parse_rhs (?rest ?ast ?depth)} <= {
		#:dummy tau_builtins:output "parse_rhs".
	?ast a :node. ?ast :type ?rhs. ?ast :children ?ch.
	(?x0 ?grammar ?rhs) :parse_rhs_items (?rest ?ch ?depth).
}.

{(?x0 ?grammar ?rhs_) :parse_rhs_items (?rest ?ch_ ?depth)} <= {
		#:dummy tau_builtins:output "parse_rhs_items".
	(?x0 ?grammar ?rhsf) :parse_rhs_item (?after_item ?chf ?depth).
	(?after_item ?grammar ?rhsr) :parse_rhs_items (?rest ?chr ?depth).
}.

{(?x0 ?grammar rdf:nil) :parse_rhs_items (?x0 rdf:nil ?depth)} <= {
		#:dummy tau_builtins:output "parse_rhs_items nil".
}.

{(?x0 ?grammar ?rhs_item) :parse_rhs_item (?rest ?ast ?depth)} <= {
	?rhs_item a :literal. ?rhs_item :value ?dcgv. 
		#:dummy tau_builtins:output "parse_rhs_item(lit):".
	?astv string_builtins:strXlst ?dcgv. 
		:dummy tau_builtins:output "parse_rhs_item(lit):".
		?dummy tau_builtins:output ?astv.
	?ast a :literal. ?ast :value ?astv.
	:dummy :literally_list (?x0 ?rest ?dcgv).
	    ?dummy tau_builtins:output ?astv.
	    ?dummy tau_builtins:output "matches".
}.

{(?x_ ?grammar ?rhs_item) :parse_rhs_item (?xr ?ast ?depth)} <= {
	?rhs_item a :any_char_except. ?rhs_item :value ?except.
		:dummy tau_builtins:output "parse_rhs_item(any char except):".
	?xf string_builtins:any_char_except ?except.
 	?ast a :literal. ?ast :value ?xf.
}.

{(?x0 ?grammar ?rhs_item) :parse_rhs_item (?rest ?ast ?depth)} <= {
	?rhs_item a :all_chars_until_one_of. ?rhs_item :value ?except.
	    :dummy tau_builtins:output "parse_rhs_item(all_chars_until_one_of):".
 	?ast a :literal. ?ast :value ?string.
	?x0 :all_chars_until_one_of (?rest ?except ?char_list).
    ?string string_builtins:strXlst ?char_list.
}.

{(?x0 ?grammar ?rhs_item) :parse_rhs_item (?rest ?ast ?depth)} <= {
		#:dummy tau_builtins:output "parse_rhs_item(nont):".
	?rhs_item a :identifier. ?rhs_item :name ?name. 
		#:dummy tau_builtins:output "parse_rhs_item(nont):". :dummy tau_builtins:output ?name.
		#:dummy tau_builtins:output "parse_nonterminal:".
		#:dummy tau_builtins:output ?name.
	(?x0 ?grammar ?name) :parse_nonterminal (?rest ?ast ?depth).
}.

{?x_ :all_chars_until_one_of (?rest ?except ?char_list_).} <= {
    ?xf string_builtins:any_char_except ?except.
    ?char_listf :eq ?xf.
    ?xr :all_chars_until_one_of (?rest ?except ?char_listr).
}.

{?x_ :all_chars_until_one_of (?x_ ?except rdf:nil).} <= {
    ?except string_builtins:strXlst ?except_list.
    ?xf :memberof ?except_list.
}.





:grammar_of_initial_ldl :has_value
"""
string_literal --> [\\[], string_literal_body, [\\]].

string_literal_body --> string_literal_body_item, string_literal_body.
string_literal_body --> .

string_literal_body_item --> any char except [\\n\\[\\]\\\\].
string_literal_body_item --> [\\\\n].
string_literal_body_item --> [\\\\\\[].
string_literal_body_item --> [\\\\\\]].
string_literal_body_item --> [\\\\\\\\].

node_name --> node_name_unquoted.
node_name_unquoted --> string_literal_body.
node_name --> node_name_quoted.
node_name_quoted --> string_literal.

statements --> statement, [.\\n], statements.
statements --> comment, [\\n], statements.
statements --> [\\n], statements.
statements --> .

statement --> x_is_a_series_of_y_separated_with_z.
x_is_a_series_of_y_separated_with_z --> node_name, [ is a series of ], node_name, [ separated with ], string_literal.

statement --> subtype.
subtype --> node_name, [ works as ], node_name.

statement --> grammar.
grammar --> node_name, [ ++> ], grammar_items, [.].

comment --> [#], all chars until one of [\\n].

grammar_items --> grammar_item, [, ], grammar_items.
grammar_items --> grammar_item.
grammar_items --> .

grammar_item --> string_literal.
grammar_item --> node_name.
grammar_item --> node_name_with_child_name.
grammar_item --> any_char_except.
grammar_item --> all_chars_until_one_of.

any_char_except --> [any char except ], string_literal.
all_chars_until_one_of --> [all chars until one of ], string_literal.

node_name_with_child_name --> node_name, [:], node_name.

""";
:has_comment """
need to extend the simple dcg parser with "any char except"
then build a parser that works off that ast. i already have a parser that works off a simple dcg, so i'd extend it.
""".


:initial_ldl_text :has_value
"""

""";
:has_comment """
this is a declarative definition of the basic building blocks of the ldl and their grammar.
probably just dcg + "any char except" +  optional child names + "indent"/"dedent" special syntax items.
now we need to turn this into (at least in-memory) ldl ast.
""".




#string_literal --> [\\[], string_literal_body, [\\]].
    {?parsed :parsed2builtins ?ldl} <=
    {
        ?parsed :type "string_literal"; :children (?x_0 ?body ?x_1).
        ?ldl a ldl:string_literal; :value ?body!:parsed2builtins^string_builtins:strXlst.
    }.

#string_literal_body --> string_literal_body_item, string_literal_body.
    {?parsed :parsed2builtins ?ldl_} <=
    #parsed is a node:
    #   children is a list of nodes:
    #       string_literal_body_item
    #       string_literal_body
    #ldl is a list of chars
    {
        ?parsed :type "string_literal_body".
        ?parsed :children (?string_literal_body_item ?string_literal_body).
        ?string_literal_body_item :children (?lit).
        ?lit :value ?ldlf.
        ?string_literal_body :parsed2builtins ?ldlr.
    }.
#string_literal_body --> .
    {?parsed :parsed2builtins rdf:nil} <=
    {
        ?parsed :type "string_literal_body". ?parsed :children rdf:nil.
    }.










#node_name_with_child_name --> node_name, [:], node_name.
{?parsed :parsed2builtins ?ldl_} <=
{
    ?parsed :type "node_name_with_child_name". ?parsed :children ?ch0_.
    ?ch0f a :node. ?chf :parsed2builtins ?ldlf.
    ?chr :parsed2builtins ?ldlr.
}.

#statements --> statement, [.\\n], statements.
#statements --> comment, [\\n], statements.
{?parsed :parsed2builtins ?ldl_} <=
{
    ?parsed :type "statements". ?parsed :children ?ch_.
    ?chf a :node. ?chf :parsed2builtins ?ldlf.
    ?chr :parsed2builtins ?ldlr.
}.

#statements --> [\\n], statements.
{?parsed :parsed2builtins ?ldl_} <=
{
    ?parsed :type "statements". ?parsed :children ?ch_.
    ?chf a :literal. ?ldlf a ldl:newline.
    ?chr :parsed2builtins ?ldlr.
}.

#statements --> .
{rdf:nil :parsed2builtins rdf:nil} <=
{}.





#data declarations
#some of these are used both in the concrete and in the abstract phase, so typing differs

{?x a :statement.  ?x :lhs ?Y. ?x :rhs ?Z} <= {}.
{?x a :identifier.  ?x :name ?NAME} <= {}.
# - name is a string
{?x a :literal.  ?x :value ?vALUE} <= {}.
# - value is a string or a list of chars
{?x a :any_char_except.  ?x :value ?vALUE} <= {}.
# - value is a string
{?x a :all_chars_until_one_of.  ?x :value ?vALUE} <= {}.
# - value is a string
{?x a :newline} <= {}.
{?x a :node. ?x :type ?NONT. ?x :children ?CH.} <= {}.








ldl:newline a ldl:node.





fin.




query
:dummy tau_builtins:toggle_tracing :dummy.
:grammar_of_initial_ldl :has_value ?v.
?v string_builtins:strXlst ?l.
:dummy :statement_lines (?l rdf:nil ?grammar_concrete).
:dummy tau_builtins:output "dcg parsed.".
?grammar_concrete :concrete_to_abstract ?grammar.
:initial_ldl_text :has_value ?initial_ldl_text_value.
?initial_ldl_text_value string_builtins:strXlst ?initial_ldl_text_list.
(?initial_ldl_text_list ?grammar "statements") :eq ?a1.
(rdf:nil ?initial_ldl :minus_one) :eq ?a2.
:dummy tau_builtins:output "parse_nonterminal...".
:dummy tau_builtins:toggle_tracing :dummy.
?a1 :parse_nonterminal ?a2.
?initial_ldl :parsed2builtins ?builtins_statements.

fin.
shouldbetrue











query
#generation of text from grammar, with max depth
"""
sentence --> noun_phrase, space, verb_phrase.
noun_phrase --> determiner, space, noun.
verb_phrase --> verb, space, noun_phrase.
verb_phrase --> verb, space, sentence.
space --> [ ].
determiner --> [the].
determiner --> [a].
noun --> [cat].
noun --> [mouse].
noun --> [dinosaur].
verb --> [scares].
verb --> [hates].
verb --> [chases].
""" string_builtins:strXlst ?l.
:dummy :statement_lines (?l rdf:nil ?grammar_concrete).
?grammar_concrete :concrete_to_abstract ?grammar.
:zero :has_succ ?one.
?one :has_succ ?two.
?two :has_succ ?three.
?three :has_succ ?four.
?four :has_succ ?five.
?five :has_succ ?six.
?six :has_succ ?seven.
?seven :has_succ ?eight.
?eight :has_succ ?nine.
?nine :has_succ ?ten.
(?generated_list ?grammar "sentence") :parse_nonterminal (rdf:nil ?sentence ?ten).
?generated_string string_builtins:strXlst ?generated_list.
:dummy tau_builtins:output ?generated_string.
fin.













query
"""
sentence --> noun_phrase, space, verb_phrase.
noun_phrase --> determiner, space, noun.
verb_phrase --> verb, space, noun_phrase.
verb_phrase --> verb, space, sentence.
space --> [ ].
determiner --> [the].
determiner --> [a].
noun --> [cat].
noun --> [mouse].
noun --> [dinosaur].
verb --> [scares].
verb --> [hates].
verb --> [chases].
""" string_builtins:strXlst ?l.
:dummy :statement_lines (?l rdf:nil ?grammar_concrete).
?grammar_concrete :concrete_to_abstract ?grammar.
"the cat chases the dinosaur" string_builtins:strXlst ?input.
:dummy tau_builtins:output "parse..".
(?input ?grammar "sentence") :parse_nonterminal (rdf:nil ?sentence :minus_one).
fin.
shouldbetrue





#{?x a :world. ?x :has_modules ?MODULES} <= {}.




#{?path :run :dummy} <= {
#    ?path :load ?modules.
#}.

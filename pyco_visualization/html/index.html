<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>

	<script type="text/javascript" src="vue.js"></script>
	<script type="text/javascript" src="jquery-3.3.1.js"></script>
	<script src="lodash.js"></script>

	<link rel="stylesheet" href="styles.css">
</head>
<body>
<div id="top">
		<div>last_loaded_file_id: {{ last_loaded_file_id }}, status: {{ file_status }}</div>
		<div>navigation status: {{ navigation_status }}</div>
		<div>step: {{ view.step_id }}</div>
		<coro_state :coro_state="view.root"></coro_state>
		<div> {{ view.yield_count }} </div>
		<div> {{ rules }} </div>
</div>
<script type="text/javascript">

	Vue.component('coro_state', {
		props: ["coro_state"],
		template: `
			<div class="coro_state">
			{{ coro_state.status }} - {{ coro_state.comment }}
			<ul>
			<div v-for="child in coro_state.children" :key="child.id">
				<li>
				<coro_state :coro_state="child"></coro_state>
				</li>
			</div>
			</ul>
			</div>
		`
	});
	var vm = new Vue({
		el: '#top',
		data: {
			view:{
				root:
				{
					status:"hello! loading and parsing trace file...hopefully... ... you have a trace file, right?...",
					children:[],
				},
				step_id: -1,
				yield_count: 0,
			},
			display_rules:[
				{action:"hide",filter:{rule: 0}},
				{action:"hide",filter:{rule: 1}},
			],
			run_uuid: undefined,
			files:[],
			last_loaded_file_id: -1,
			file_status: "?",
			navigation_status: "?",
			rules:{}
		},
		mounted: function ()
		{
			window.addEventListener('keydown', function (event) {
				c = event.keyCode;
				console.log(c);
				if (c==188 && vm.view.step_id > 0)
				{
					prev_step();
				}
				if (c==190 && vm.steps.length > 0)
				{
					vm.navigation_status = "going to next step.."
					go_to_next_step();
					vm.navigation_status = "idle"
				}
				if (c==107 && vm.steps.length > 0)
					go_to_next_deeper_step();
				if (c==191 && vm.steps.length > 0)
				{
					vm.navigation_status = "going to next yield.."
					go_to_next_yield();
					vm.navigation_status = "idle"
				}
				if (c==221)
				{
					console.log("ffffff")
					ff();
				}
			});
		}
	});

	const snapshot_interval = 80;
	const word_size = 8;

	function maybe_take_snapshot()
	{
		const step_id = vm.view.step_id;
		if (step_id % snapshot_interval == 0)
			if (vm.snapshots[step_id] === undefined)
				vm.snapshots[step_id] = _.cloneDeep(vm.view);
	}
/*	function go_to_next_deeper_step()
	{
		console.log("go_to_next_deeper_step");
		move_view_to_next_step(vm.view)
	}*/
	function go_to_next_yield()
	{
		console.log("go_to_next_yield");
		const old_yields = vm.view.yield_count;
		for (i = 0; i < 100; i++)
		{
			if (!go_to_next_step())
				break;
			if (old_yields < vm.view.yield_count)
				break;
		}
	}
	function ff()
	{
		console.log("ff");
		for (var i = 0; i < 50000; i++)
		{
			if (!move_view_to_next_step(vm.view))
				break;
		}
	}
	function go_to_next_step()
	{
		console.log("go_to_next_step");
		maybe_take_snapshot();
		return move_view_to_next_step(vm.view)
	}
	function move_view_to_next_step(view)
	{
		const wanted_id = view.step_id + 1
		const step = vm.steps[wanted_id];
		if (step != undefined)
		{
			view.step_id++
			for (i = 0; i < step.length; i++)
				if (!do_op(step[i], view))
					return false
			return true;
		}
		else
		{
			load_file_for_step(wanted_id);
			return false;
		}
	}
	function load_file_for_step(wanted)
	{	/*
		files.forEach(file => {
			if (file.status == FileStatus.unloaded)
			{
				if (file.start <= wanted && file.end >= wanted)

		})
		*/
		load_file(vm.last_loaded_file_id + 1);
	}
	function load_file(id)
	{
		if (vm.file_status == "loading")
			return
		vm.file_status = "loading"
		$.getScript( "../trace"+id+".js", function( data, textStatus, jqxhr )
		{
			console.log( textStatus ); // Success
			console.log( jqxhr.status ); // 200
			console.log( "Load was performed." )
			//if (view.step_id == -1)
			go_to_next_step();
			vm.last_loaded_file_id++
			vm.file_status = "loaded"
		});
	}
	function prev_step()
	{
		console.log('prev_step')
		const wanted = vm.view.step_id - 1;
		let best = 0; // we never delete the 0 snapshot
		for (let idx = 0; idx < vm.snapshots.length; idx++)
		{
			if (idx > wanted)
				break;
			let snapshot = vm.snapshots[idx]
			if (snapshot != undefined)
				best = idx
		}
		//now best is the position of the closest snapshot
		let snapshot = _.cloneDeep(vm.snapshots[best])
		while (wanted > snapshot.step_id)
		{
			if (!move_view_to_next_step(snapshot))
			{
				alert("fail");
				return;
			}
		}
		assert (snapshot.step_id == wanted);
		assign_cloned_snapshot_to_view(snapshot);
	}
	function assign_cloned_snapshot_to_view(snapshot)
	{
		assign_cloned_snapshot_to_view1(snapshot)
		assign_cloned_snapshot_to_view2(snapshot)
		vm.view.step_id = snapshot.step_id;
	}
	function assign_cloned_snapshot_to_view1(snapshot)
	{
		vm.view.index = snapshot.index;
	}
	function assign_cloned_snapshot_to_view2(snapshot)
	{
		vm.view.root = snapshot.root
	}
	function do_op(op, view)
	{
		if (!Array.isArray(op))
		{
			if (op["a"] == "run_uuid")
			{
				uuid = op["value"]
				if (vm.run_uuid === undefined)
					vm.run_uuid = uuid
				else if (vm.run_uuid != uuid)
				{
					files[file_id].status = FileStatus.error
					alert("uuids dont match");
					return false
				}
			}
			else if (op["a"] == "consts_address")
			{
				emit me in pyco
				vm.rules[op["rule"]].consts_address = op["value"]
			}
			else
				alert("unknown action in " + op)
			return true
		}
		const action = op[0]
		const id = op[1]
		if (action == OP_SET_COMMENT)
		{
			if (view.index[id] == undefined)
				alert("comment before status for id "+id);
			view.index[id].comment = op[2];
		}
		else if (action == OP_SET_STATUS)
		{
			//console.log(op.id + " status "  +  coro_status[op.status]);
			parent_id = op[3]
			if (view.index[id] == undefined)
			{
				if (parent_id == undefined)
					alert("first status but no parent id?");
				if (!add_state(op, view))
					return
			}
			rule_id = op[4]
			comment = op[6]
			if (comment != undefined)
				view.index[id].comment = comment;

			status = op[2]
			const old_status_string = view.index[id].status;
			const new_status_string = coro_status[status];
			const yield_statuses = ["EP", "YIELD", "BNODE_YIELD"];
			if (yield_statuses.includes(old_status_string) && !yield_statuses.includes(new_status_string))
				assert(--view.yield_count > 0)
			else if (yield_statuses.includes(new_status_string) && !yield_statuses.includes(old_status_string))
				view.yield_count++

			view.index[id].status = new_status_string

			//console.log(id+" status:"+status)
			if (status == 0)
			{
				if (view.index[id].children.length)
				{
					//console.log("deleting inactive parent's children")
					/*when a state is inactivated, its children
					will never be used again*/
					view.index[id].children.forEach(child =>
						remove_state(child.id, view));
					view.index[id].children = []
					//if (view.index[id].parent == view.root)
					//remove_state(id, view);
				}
				//else console.log("chl")

			}
			//else console.log(id+" status != 0")

		}
		else if (action == OP_BIND) {
			what = 0 + op[1]
			where = 0 + op[2]
			what_thing = undefined
			where_thing = undefined
			view.index.forEach(state => {
				thing = local_for_state(state, what)
				if (thing !== undefined) {
					what_thing = thing
					if (where_thing) {
						bind(what_thing, where_thing);
						return true;
					}
				}
				thing = local_for_state(state, where)
				if (thing !== undefined) {
					where_thing = thing
					if (what_thing) {
						bind(what_thing, where_thing);
						return true;
					}
				}
			});
			rm.rules.forEach(rule => {
				thing = local_for_state(state, what)
				if (thing !== undefined) {
					what_thing = thing
					if (where_thing) {
						bind(what_thing, where_thing);
						return true;
					}
				}
				thing = local_for_state(state, where)
				if (thing !== undefined) {
					where_thing = thing
					if (what_thing) {
						bind(what_thing, where_thing);
						return true;
					}
				}
			});

		}
		else if (action == OP_UNBIND) {
			what = 0+op[1]
			view.index.forEach(state => {
				thing = local_for_state(state, what)
				if (thing !== undefined)
				{
					thing.bound_to = undefined;
					return true;
				}
			});
		}
		else
			alert("unknown action: "+action)
		return true
	}
	function bind(what_thing, where_thing) {
		what_thing.bound_to = where_thing;
	}
	function local_for_state(state, what)
	{
		fixme
		idx = what - state.locals_address
		if (idx >= 0 && idx <= (rule_for_state(state).locals_size - 1) * thing_size)
			return state.locals[idx/thing_size]
	}
	function const_for_rule(rule, what)
	{
		fixme
	}
	function add_state(op, view)
	{
		state = {"children":[],"status":"idk"};
		state.id = op[1];
		const parent_id = op[3];
		state.parent_id = parent_id;
		if (view.index.hasOwnProperty(parent_id))
			parent = view.index[parent_id]
		else
			parent = view.root
		state.parent = parent
		parent.children.push(state)
		view.index[state.id] = state;
		state.locals_address = op[5]
		rule = rule_for_state(state)
		locals = locals_for_rule(rule)
		locals_count = locals.length
		state.locals = Array(locals_count)
		forEach(_.range(), i => {
			state.locals[i] = {}
		});
		return true;
	}
	function locals_for_rule(rule)
	{
		return rule["k:has_locals"]["rdf:value"]["@list"]
	}
	function rule_for_state(state)
	{
		return vm.rules[state.rule_id]
	}

	function remove_state(id, view)
	{
		delete view.index[id]
	}

	const FileStatus = Object.freeze({error:1, loading:2, loaded:3, unloaded:4})
	const coro_status = ["INACTIVE", "ACTIVE", "EP", "YIELD", "BNODE_YIELD"]
	const OP_SET_COMMENT = 0;
	const OP_SET_STATUS = 1;
	const OP_BIND = 2;
	const OP_UNBIND = 3;


	$( document ).ready(function() {

/*we initialize these from here, because if they were in the initial data declaration, vue would reactivize them
and things would get silly slow. I first looked for solutions like this one:
//Object.defineProperty(vm.view, 'index', {configurable:false});
but none worked*/

vm.view.index = {}
vm.snapshots= []
vm.steps= []

console.log( "ready!" );

//vm.rules = {}

$.ajax({
	dataType: "json",
	url: "../rules.jsonld",
	data: "",
	success: function(data)
	{

		g = data["@graph"]
		g.forEach(rule => {
			//console.log(rule)
			vm.rules[rule["k:has_id"]["@value"]] = rule
	})

	}
});

load_file(0)

});

	/*this is the function called from withing the trace files*/
	function S(x)
	{
		vm.steps.push(x);
	}


function assert(condition, message) {
    if (!condition) {
        message = message || "Assertion failed";
        if (typeof Error !== "undefined") {
            throw new Error(message);
        }
        throw message; // Fallback
    }
}

</script>
</body>
</html>
